<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ê°ì • ê·¸ë˜í”„</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    max-width: 900px;
    margin: 2em auto;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #fafafa;
    color: #222;
  }
  h1, h2 {
    text-align: center;
    margin-bottom: 0.5em;
  }
  canvas {
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 3px 8px rgb(0 0 0 / 0.1);
    margin-bottom: 3em;
  }
</style>
</head>
<body>

<h1>ê°ì • ê·¸ë˜í”„</h1>

<h2>ê°ì • í™•ë¥ </h2>
<canvas id="chart-emotion-label" width="800" height="400"></canvas>
<h2>ê°ì •êµ° í™•ë¥ </h2>
<canvas id="chart-emotion-group" width="800" height="400"></canvas>
<h2>ê°ì • Zê°’</h2>
<canvas id="chart-emotion-label-z" width="800" height="400"></canvas>
<h2>ê°ì •êµ° Zê°’</h2>
<canvas id="chart-emotion-group-z" width="800" height="400"></canvas>

<script>

//png ì €ì¥ ì½”ë“œ
/*
document.querySelectorAll('canvas').forEach((canvas, i) => {
  const imgDataUrl = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = imgDataUrl;
  a.download = `canvas_${i + 1}.png`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  console.log(`canvas_${i + 1}.png ì €ì¥ ì‹œì‘`);
});
*/

  // íŒŒìŠ¤í…” í†¤ ìƒ‰ìƒ ë°°ì—´ (ëª…ë„ ì‚´ì§ ë‹¤ë¥´ê²Œ)
  const positiveColors = ['#8b73ff', '#9a82ff', '#a28bff', '#8c7dff', '#7b6cff']; // íŒŒìŠ¤í…” ë³´ë¼ ê³„ì—´
  const negativeColors = ['#ffa8dc', '#ffb3dd', '#ff9fcf', '#ffbadc', '#ff8fbf']; // íŒŒìŠ¤í…” í•‘í¬ ê³„ì—´
  const neutralColors  = ['#a8d0ff', '#91bfff', '#b3d7ff', '#8fceff', '#9ad6ff']; // ì¤‘ë¦½ íŒŒìŠ¤í…” ë¸”ë£¨ ê³„ì—´

  // ê°ì •ë³„ ë¶„ë¥˜ ë§µ (ë¼ë²¨ëª… ì •í™•íˆ ì…ë ¥)
  const emotionCategoryMap = {
    "ë¶„ë…¸": "negative",
    "ë¶ˆì•ˆ": "negative",
    "ìŠ¬í””": "negative",
    "í˜ì˜¤": "negative",
    "ì¤‘ë¦½": "neutral",
    "ê¸°ì¨": "positive",
    "ë‹¹í™©": "negative"
  };

  // ë¼ë²¨ëª… ì†Œë¬¸ì ë¹„êµ í›„ ì¹´í…Œê³ ë¦¬ ë°˜í™˜
  function getEmotionCategory(label) {
    const normalized = label.trim().toLowerCase();
    for (const [key, category] of Object.entries(emotionCategoryMap)) {
      if (key.toLowerCase() === normalized) return category;
    }
    return 'neutral';  // ê¸°ë³¸ê°’
  }

  function hexToRgba(hex, alpha) {
    if (typeof hex !== 'string' || !hex.startsWith('#')) return hex;
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  async function loadChart(jsonPath, canvasId, yLabel, individualColors=false) {
    const response = await fetch(jsonPath);
    const chartData = await response.json();
    const ctx = document.getElementById(canvasId).getContext('2d');
    const isZscore = yLabel.toLowerCase().includes("z");

    const datasetsWithColors = chartData.datasets.map((ds, idx) => {
      let borderColor;
      if(individualColors) {
        // ê°œë³„ ê°ì •ìš©: ê°ì •ë³„ ë¶„ë¥˜ì— ë”°ë¼ ìƒ‰ìƒ ì„ íƒ
        const category = getEmotionCategory(ds.label);
        let colorArray;
        if(category === 'positive') colorArray = positiveColors;
        else if(category === 'negative') colorArray = negativeColors;
        else colorArray = neutralColors;
        borderColor = colorArray[idx % colorArray.length];
      } else {
        // ê°ì •êµ° ì§‘ê³„ìš© (ê°„ë‹¨í•˜ê²Œ 'ì¤‘ë¦½' ìˆìœ¼ë©´ neutral, ì•„ë‹ˆë©´ positive/negative êµ¬ë¶„)
        const labelLower = ds.label.trim().toLowerCase();
        if (labelLower.includes('ì¤‘ë¦½')) {
          borderColor = neutralColors[idx % neutralColors.length];
        } else if (labelLower.includes('ê¸°ì¨') || labelLower.includes('positive') || labelLower.includes('ê¸ì •')) {
          borderColor = positiveColors[idx % positiveColors.length];
        } else if (labelLower.includes('ë¶„ë…¸') || labelLower.includes('ë¶ˆì•ˆ') || labelLower.includes('ë¶€ì •') || labelLower.includes('ìŠ¬í””') || labelLower.includes('í˜ì˜¤') || labelLower.includes('ë‹¹í™©')) {
          borderColor = negativeColors[idx % negativeColors.length];
        } else {
          borderColor = '#999999'; // ê¸°íƒ€ ìƒ‰ìƒ
        }
      }
      return { ...ds, borderColor };
    });

    // ê·¸ë¼ë””ì–¸íŠ¸ ìƒì„±
    const gradients = datasetsWithColors.map(ds => {
      const color = ds.borderColor || '#000000';
      const gradient = ctx.createLinearGradient(0, 0, 0, 400);
      gradient.addColorStop(0, hexToRgba(color, 0.5));
      gradient.addColorStop(1, hexToRgba(color, 0));
      return gradient;
    });

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: chartData.labels,
        datasets: datasetsWithColors.map((ds, idx) => ({
          ...ds,
          borderWidth: 2,
          tension: 0.4,
          pointRadius: 2,
          pointHoverRadius: 4,
          pointStyle: 'circle',
          pointBorderWidth: 1.5,
          pointBackgroundColor: '#fff',
          pointBorderColor: ds.borderColor || '#000000',
          fill: true,
          backgroundColor: gradients[idx]
        }))
      },
      options: {
        responsive: true,
        plugins: {
          legend: { position: 'right' },
          tooltip: {
            callbacks: {
              title: (ti) => `ğŸ“… ì—°ë„: ${ti[0].label}`,
              label: (ti) => {
                const unit = isZscore ? "" : " (í™•ë¥ )";
                const val = isZscore ? ti.raw.toFixed(2) : (ti.raw * 100).toFixed(1) + "%";
                return `${ti.dataset.label}: ${val}${unit}`;
              },
              footer: (ti) =>
                isZscore ? "ê¸°ì¤€: ì „ì²´ í‰ê·  ëŒ€ë¹„ í‘œì¤€í¸ì°¨" : "ê¸°ì¤€: ê°ì • ì ìˆ˜ í‰ê· "
            },
            backgroundColor: 'rgba(0,0,0,0.8)',
            titleFont: { weight: 'bold', size: 14 },
            bodyFont: { size: 13 },
            footerFont: { style: 'italic' },
            padding: 12,
            cornerRadius: 6
          }
        },
        interaction: { mode: 'nearest', axis: 'x', intersect: false },
        scales: {
          y: { title: { display: true, text: yLabel }, beginAtZero: true },
          x: { title: { display: true, text: 'ì—°ë„' } }
        }
      }
    });
  }

  // 4ê°œ ì°¨íŠ¸ ë¡œë“œ
  loadChart('emotion_label_data.json', 'chart-emotion-label', 'ê°ì • í™•ë¥  í‰ê· ', true);
  loadChart('emotion_group_data.json', 'chart-emotion-group', 'ê°ì • í™•ë¥  í‰ê· ');
  loadChart('emotion_label_zscore_data.json', 'chart-emotion-label-z', 'Z-score', true);
  loadChart('emotion_group_zscore_data.json', 'chart-emotion-group-z', 'Z-score');

</script>

  <!-- ğŸ”’ ìˆ¨ê²¨ì§„ ë°©ë¬¸ì ìˆ˜ íŠ¸ë˜ì»¤ (Shift + Vë¡œ í‘œì‹œ) -->
<div id="visitor-counter" style="display:none; position:fixed; bottom:10px; right:10px; background:rgba(0,0,0,0.7); color:white; padding:6px 10px; border-radius:8px; font-family:sans-serif; z-index:9999;">
<a href="https://hits.sh/mg10240.github.io/Emotion_data_visualization/"><img alt="Hits" src="https://hits.sh/mg10240.github.io/Emotion_data_visualization.svg?view=today-total&style=for-the-badge&color=f6f6f6&labelColor=f0e8ff"/></a>
</div>
<script>
  document.addEventListener("keydown", function(e) {
    if (e.shiftKey && e.key === "V") {
      const counter = document.getElementById("visitor-counter");
      counter.style.display = counter.style.display === "none" ? "block" : "none";
    }
  });
</script>

</body>
</html>
